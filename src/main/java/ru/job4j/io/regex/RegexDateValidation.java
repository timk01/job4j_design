package ru.job4j.io.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * базово - Допустим, нам нужно найти в тексте дату, записанную в виде "дд.мм.гггг".
 * Чтобы создать корректный шаблон для поиска, нужно разделить данную дату на последовательности
 * символов (из чего состоит). В нашем случае это 2 цифры, точка, 2 цифры, точка, 4 цифры.
 * т.е.\\d{2}\\.\\d{2}\\.\\d{4}
 *
 * \\b\\d{2}\\.\\d{2}\\.\\d{4}\\b - для цельного литерала (отдельная строка, "соло")
 * (здесь {} - количество повторово
 *
 * шаблон можно дополнить еще ограничениями, чтобы дата была цельным литералом
 * (не была частью другого литерала), сделать ограничение по году (не может быть более 20**),
 * по месяцу (не может быть более 12), дням (не может быть более 31) и т.д.
 *
 * [0-2]{1}[0]{1}\d{2} или [0-2][0]\d{2} , т.к. {1} не нужно
 * - вот например по году (0, 1 или 2 - первый символ), 0 - второй, далее любой
 * (т.е. ограничение на первые 2)
 *
 * что такое 12 ? это 1 символ (месяц) или 2, если 1, то 1-9, если 2, то 10, 11, 12
 * \b([1-9]|1[0-2])\b
 * здесь 1-9 в любом случае будет, а потом будет ИЛИ 10, ИЛИ 11, или 12.
 * т.е. или это |, затем может идти 0, 1, или 2. (первое-то будет в любом случае)
 * или 1 И 0, 1 И 1, 1 И 2
 * а может и не идти.
 *
 * \b([1-9]|[12][0-9]|3[01])\b
 * здесь 1-9 в любом случае будет
 * затем ИЛИ. 10-29 - это 10 to 29 --> [12][0-9], читать как "сначала 1 ИЛИ 2, потом 0-9
 * т.е. минимально возможное - 1 И 0, максимально - 2 И 9
 * ИЛИ 30-31, т.е 3 И 0, 3 И 1
 */

public class RegexDateValidation {
    public static void main(String[] args) {
        Pattern pattern = Pattern.compile("\\b\\d{2}\\.\\d{2}\\.\\d{4}\\b");
        String text = "24.04.1987 11.11.111111 99.99.99991 99.99.9999 99999999 0000.00.00";
        Matcher matcher = pattern.matcher(text);
        while (matcher.find()) {
            System.out.println("Найдено совпадение: " + matcher.group());
        }
    }
}