package ru.job4j.map;

public class LogicOperations {
    public static void main(String[] args) {
        int i = 5;
        System.out.println(~5);

        boolean b1 = false;
        boolean c1 = true;
        System.out.println(b1 & c1);

        /**
         * Необходимо поменять их местами без использования дополнительной переменной.
         * Через "+" чревато переполнением, для больших интов
         * Через "\*\" чревато делением на нуль
         * Через Ксор - ОК
         */

        int a = 5;
        int b = 9;
        a = a + b;
        b = a - b;
        a = a - b;
        System.out.println("a: " + a);
        System.out.println("b: " + b);

        System.out.println();
        a = a * b;
        b = a / b;
        a = a / b;
        System.out.println("a: " + a);
        System.out.println("b: " + b);

        System.out.println();
        a = a ^ b;
        b = a ^ b;
        a = a ^ b;
        System.out.println("a: " + a);
        System.out.println("b: " + b);

        /**
         * Даны два числа K, N. Необходимо вычислить арифметическое выражение вида:
         * K * 2^N, используя только битовые операции. (Здесь знак ^ означает степень числа).
         *
         * Например для К = 3, Эн = 4. Вручную это 3*16 (а 16 - степень двойки)
         * Умножение числа на 2 в степени N эквивалентно сдвигу влево на N позиций.
         * K << N = 3 << 4 = 110000 = 48
         */

        System.out.println();
        int k = 3;
        int n = 4;
        int res = 3 << 4;
        System.out.println(res);

        /**
         * Реализуйте Java метод, который возвращает количество бит,
         * которое необходимо поменять для преобразования числа X в число Y и наоборот.
         * Метод должен принимать два различных целых числа на входе.
         * Например, для чисел 12 и 16 метод должен вернуть 3.
         *
         * Для решения данной задачи следует применить оператор XOR(^),
         * поскольку результат для чисел X и Y будет двоичным числом, каждый бит которого будет равен 1,
         * если их биты отличаются между собой, или 0, когда биты одинаковы.
         * Так, например, если мы применим XOR к 1001 и 0101, результат операции XOR будет 1100,
         * потому что два крайних левых бита отличаются друг от друга (см. задачу 1),
         * поэтому результат применения оператора XOR к этим двум битам будет 1,
         * а два самых правых бита в наших входящих числах одинаковы,
         * поэтому результат XOR будет равен 0.
         *
         *
         * Пример. 12 и 16. 12 это 0000 1100 (4+8), 16 это 0001 0000 (16)
         * После ксора это 0001 1100 (24)
         * После & 1 = это 0 только если правый крайний бит не 1 (что будет в случае 0000 0111 и так далее)
         * Т.е. это та самая ситуцаия когда каунтер +1.
         * Ну и эту штуку мы сдвигаем вправо каждый раз, пока она не будет 0000 0000 (или нуль)
         * Результат = 3.
         */

        System.out.println();
        System.out.println(findNumberOfBits(12, 16));
    }

    public static int findNumberOfBits(int x, int y) {
        int bitCount = 0;
        int z = x ^ y;
        while (z != 0) {
            bitCount += z & 1;
            z = z >> 1;
        }
        return bitCount;
    }
}
